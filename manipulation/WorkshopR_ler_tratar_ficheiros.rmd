---
title: "workshopR_ler_tratar_ficheiros"
author: "Xavier Pinho"
date: "21 de Marco de 2018"
output: pdf_document
---

library(dplyr)
library(tidyr)

###Criar uma directoria para este ficheiro
```{r}
home <- 'C:/Users/Xavier/Documents/R/workshopR_jest'
setwd(home)
```

###Ler e tratar ficheiros

data.frames forma mais comum de armazenar e manipular dados no R.
data.frames são listas de vetores todos com o mesmo comprimento.

As funções mais importantes para ler ficheiros são:
```{r}
read.table()
read.csv()
read.csv2()
read.delim()
```
entre outras
Todas estas funções lêm um ficheiro e criam um data frame.

Argumentos:
file -> url completo, nome.formato, entre aspas
Header = TRUE -> primeira linha contem os titulos
sep = "" -> de que forma os dados est?o separados
fill = TRUE -> caso haja linhas de diferentes tamanhos adiciona espacos brancos
dec -> caracter usado nos numeros decimais

Principais diferenças:

O read.table() é o formato mais comum para importar ficheiros, a função já tem os argumentos definidos por definição, contudo é possível alterá-los da forma que nós quisermos.

```{r}
df1 <- read.table("survey.csv", header = FALSE, sep = "", fill = TRUE , dec = ".")

df2 <- read.csv("survey.csv", header = T , sep = ",", fill = TRUE , dec = ".")
#TRUE OU T, FALSE OU F

df3 <- read.csv2("survey.csv", header = TRUE, sep = ";", fill = TRUE , dec = ",")

df4 <- read.delim("file", header = TRUE, sep = "\t", fill = TRUE , dec = ".")
```
______________________________________________________________________________________________
#Exercício 1:
Depois de observar a base de dados indique qual destas funções é a mais apropriada para ler o ficheiro?
a) read.table
b) read.csv
c) read.csv2
d) read.delim

Solução 1: b) read.csv
_____________________________________________________________________________________________

Depois do data frame estar criado é possível alterá-lo da maneira como quisermos.

Caso o data frame nao tenha titulos nas colunas, e possivel adicionar um vetor com os titulos, atraves de col.names.
Podemos tambem definir o tipo de variaveis de cada coluna atraves de colClasses.

```{r}
df5 <- read.csv2("survey.csv", header = T, col.names = c("coluna1"))

df6 <- read.csv2("survey.csv", header = FALSE, colClasses = c("factor", "NULL", "numeric"))
#A coluna a que corresponde o "NULL" desaparece.
```

#Representacao do data frame
```{r}
str(df2)
#informacao sobre a estrutura do objeto
summary(df2)
#informacao estatistica sobre todas as variaveis do data frame
head(df2)
#exibe a parte superior do objeto
tail(df2)
#exibe a parte inferior do objeto

```

Agora que já temos uma noção da estrutura e da forma como o nosso data frame está organizado, podemos organizá-lo da maneira mais conveniente.

```{r}
low_to_high <- arrange(df2, Age)
#subset da coluna Age do menor valor para o maior

high_to_low <- arrange(df2, desc(Age))
#subset da coluna Age do maior valor para o menor

subset1 <- filter(df2, Age>0 & Age<200)
#subset que contém apenas as linhas onde a idade é superior a 0 e menor que 200

subset2 <- select(df2, Age, Gender, state)
#subset que agrupa as colunas Age, gender, state

subset3 <- select(df2, contains("f"))
#subset que contem as colunas em que o nome tem um f

#Funções
primeiro <- first(df2$Age)

ultimo <- last(df2$Age)

minimo <- min(df2$Age)
#ou
df2[which.min(df2$Age), ]

maximo <- max(df2$Age)
#ou
df2[which.max(df2$Age), ]

media <- mean(subset1$Age) #Média das idades

variancia <- var(df2$Age) #Variância das idades

desvio_padrao <- sd(df2$Age) #Desvio Padrão das idades

```
_____________________________________________________________________________________________
#Exercicio 2:
Criar um vetor com apenas as linhas que tenham idades compreendidas inferiores a 18 anos,
e que tenham Genero como "Male":

SOLUÇÃO 2:
solucao2 <- filter(df2, Age<18 & Gender == "Male"")
_____________________________________________________________________________________________


```{r}
#Aceder a uma coluna por Nome
coluna1 <- subset1$Gender
#Aceder a uma coluna por Numero
coluna2 <- subset1[, 2]
#Aceder a uma linha (todas as colunas)
linha1 <- subset1[1,]
#Aceder a um elemento específico
elemento1 <- subset1[100,4]
#Substituir um elemento específico
subset1[1,1] <- "2014-08-27 11:30:22"


```
_____________________________________________________________________________________________
Exercício 3:
Substitua o elemento da linha 2 e coluna 4 por "Canada" no subset1.

solucao 3
subset1[2,4] <- "Canada"

_____________________________________________________________________________________________

```{r}
#Criar um data frame de raiz
nomes <- c("Coelho","Socrates","Portas","Barroso")
ano.nascimento <- c(1936,1936,1941,1934)
cabelo <- c("S","S","N","N")
meu.data.frame <- data.frame(nomes,ano.nascimento,cabelo)
#2 maneiras de adicionar colunas ao data frame
meu.data.frame$Index <- c(1,2,3,4)
meu.data.frame["MY_NEW_COLUMN"] <- NA

```
_____________________________________________________________________________________________
Exercicio 4:

Criar um data frame com 2 colunas de 4 entradas:
1 coluna -> Cores
2 coluna -> idade

Quando o data frame estiver pronto, adicione uma nova coluna:
3 coluna -> cidade

Solucao 4:
cores <- c("vermelho","azul","preto","branco")
idades <- c(23,46,73,90)
meu.data.frame1 <-data.frame(cores,idades)

cidades <- c("Porto","Coimbra","Algarve","Aveiro")
meu.data.frame1$cidades <- cidades


_____________________________________________________________________________________________

